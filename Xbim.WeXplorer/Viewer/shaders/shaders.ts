/*
* This file has been generated by spacker.exe utility. Do not change this file manualy as your changes
* will get lost when the file is regenerated. Original content is located in *.c files.
*/
export var Shaders = {
    fragment_shader: ' precision mediump float; uniform vec4 uClippingPlaneA; uniform vec4 uClippingPlaneB; uniform bool uClippingA; uniform bool uClippingB; uniform float uShadowBias; uniform float uShadowMapSize; varying vec4 vFrontColor; varying vec4 vBackColor; varying vec3 vPosition; varying float vDiscard; varying vec4 shadowPos; uniform sampler2D uDepthColorTexture; uniform bool uShadowEnabled; float decodeFloat(vec4 v) { return dot(v, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)); } float shadowDepth(sampler2D shadowSampler, vec2 uv) { float depth = decodeFloat(texture2D(shadowSampler, uv)); return depth; } float shadowPCF(vec3 vertexPos) { float depth = vertexPos.z - uShadowBias; float texelSize = 1.0 / uShadowMapSize; float shadow = 0.0; for (int x = -1; x <= 1; x++) { for (int y = 1; y <= 1; y++) { float texelDepth = shadowDepth(uDepthColorTexture, shadowPos.xy + vec2(x, y) * texelSize); if (depth < texelDepth) { shadow += 1.0; } } } shadow /= 9.0; shadow = min(1.0, shadow + 0.6); return shadow; } void main(void) { if ( vDiscard > 0.5) discard; if (uClippingA) { vec4 p = uClippingPlaneA; vec3 x = vPosition; float distance = (dot(p.xyz, x) + p.w) / length(p.xyz); if (distance < 0.0){ discard; } } if (uClippingB) { vec4 p = uClippingPlaneB; vec3 x = vPosition; float distance = (dot(p.xyz, x) + p.w) / length(p.xyz); if (distance < 0.0) { discard; } } float shadow = 1.0; if (uShadowEnabled) { shadow = shadowPCF(shadowPos.xyz); } vec4 color = gl_FrontFacing ? vFrontColor : vBackColor; gl_FragColor = vec4(shadow * color.xyz, color.a); }',
    light_shadow_fragment: ' precision mediump float; vec4 encodeFloat(float v) { vec4 result = vec4(1.0, 255.0, 65025.0, 16581375.0) * v; result = fract(result); result -= vec4(result.yzw / 255.0, 0.0); return result; } void main(void) { gl_FragColor = encodeFloat(gl_FragCoord.z); }',
    light_shadow_vertex: ' attribute highp vec3 aPosition; uniform mat4 uLightPMatrix; uniform mat4 uLightMVMatrix; void main(void) { gl_Position = uLightPMatrix * uLightMVMatrix * vec4(aPosition, 1.0); }',
    vertex_shader: ' attribute highp float aStyleIndex; attribute highp float aProduct; attribute highp vec3 aPosition; attribute highp vec2 aState; attribute highp vec2 aNormal; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uLightMVMatrix; uniform mat4 uLightPMatrix; uniform vec4 ulightA; uniform vec4 ulightB; uniform vec4 uHighlightColour; uniform float uMeter; uniform int uColorCoding; uniform int uRenderingMode; uniform highp sampler2D uStyleSampler; uniform int uStyleTextureSize; uniform highp sampler2D uStateStyleSampler; varying vec4 vFrontColor; varying vec4 vBackColor; varying vec3 vPosition; varying float vDiscard; varying vec4 shadowPos; const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0); vec3 getNormal() { float U = aNormal[0]; float V = aNormal[1]; float PI = 3.1415926535897932384626433832795; float lon = U / 252.0 * 2.0 * PI; float lat = V / 252.0 * PI; float x = sin(lon) * sin(lat); float z = cos(lon) * sin(lat); float y = cos(lat); return normalize(vec3(x, y, z)); } vec4 getIdColor(float id) { float B = floor(id / (256.0*256.0)); float G = floor((id - B * 256.0*256.0) / 256.0); float R = mod(id, 256.0); return vec4(R / 255.0, G / 255.0, B / 255.0, 1.0); } vec2 getTextureCoordinates(int index, int size) { float x = float(index - (index / size) * size); float y = float(index / size); float pixelSize = 1.0 / float(size); return vec2((x + 0.5) * pixelSize, (y + 0.5) * pixelSize); } vec4 getColor() { int restyle = int(floor(aState[1] + 0.5)); if (restyle > 224) { int index = int(floor(aStyleIndex + 0.5)); vec2 coords = getTextureCoordinates(index, uStyleTextureSize); vec4 col = texture2D(uStyleSampler, coords); if (uRenderingMode == 0) { return col; } float intensity = (col.r + col.g + col.b) / 3.0; return vec4(intensity, intensity, intensity, col.a); } vec2 coords = getTextureCoordinates(restyle, 15); return texture2D(uStateStyleSampler, coords); } void main(void) { int state = int(floor(aState[0] + 0.5)); vDiscard = 0.0; if (state == 254 || (state == 253 && uHighlightColour.a == 0.0 && uColorCoding == -1)) { vDiscard = 1.0; vFrontColor = vec4(0.0, 0.0, 0.0, 0.0); vBackColor = vec4(0.0, 0.0, 0.0, 0.0); vPosition = vec3(0.0, 0.0, 0.0); gl_Position = vec4(0.0, 0.0, 0.0, 1.0); return; } vec3 vertex = aPosition; vec3 normal = getNormal(); vec3 backNormal = normal * -1.0; shadowPos = texUnitConverter * uLightPMatrix * uLightMVMatrix * vec4(aPosition, 1.0); if (uColorCoding == -2) { float id = floor(aProduct + 0.5); vec4 idColor = getIdColor(id); vFrontColor = idColor; vBackColor = idColor; } else if (uColorCoding >= 0) { float id = float(uColorCoding); vec4 idColor = getIdColor(id); vFrontColor = idColor; vBackColor = idColor; } else { float lightAIntensity = ulightA[3]; vec3 lightADirection = normalize(ulightA.xyz - vertex); float lightBIntensity = ulightB[3]; vec3 lightBDirection = normalize(ulightB.xyz - vertex); float lightWeightA = max(dot(normal, lightADirection) * lightAIntensity, 0.0); float lightWeightB = max(dot(normal, lightBDirection) * lightBIntensity, 0.0); float backLightWeightA = max(dot(backNormal, lightADirection) * lightAIntensity, 0.0); float backLightWeightB = max(dot(backNormal, lightBDirection) * lightBIntensity, 0.0); float lightWeighting = lightWeightA + lightWeightB + 0.7; float backLightWeighting = backLightWeightA + backLightWeightB + 0.7; vec4 baseColor = vec4(1.0, 1.0, 1.0, 1.0); if (uRenderingMode == 2) { if (state == 252) { baseColor = getColor(); } else { baseColor = vec4(0.0, 0.0, 0.3, 0.5); } } if (state == 253) { baseColor = uHighlightColour; } if (uRenderingMode != 2) { baseColor = getColor(); } if (baseColor.a < 0.98 && uRenderingMode == 0) { vec3 trans = -0.002 * uMeter * normalize(normal); vertex = vertex + trans; } vFrontColor = vec4(baseColor.rgb * lightWeighting, baseColor.a); vBackColor = vec4(baseColor.rgb * backLightWeighting, baseColor.a); } vPosition = vertex; gl_Position = uPMatrix * uMVMatrix * vec4(vertex, 1.0); }'
}
