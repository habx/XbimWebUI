"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
* This file has been generated by spacker.exe utility. Do not change this file manualy as your changes
* will get lost when the file is regenerated. Original content is located in *.c files.
*/
exports.PulseShaders = {
    pulse_fshader: "\nprecision highp float;\n\nuniform vec4 uClippingPlaneA;\nuniform vec4 uClippingPlaneB;\nuniform bool uClippingA;\nuniform bool uClippingB;\n\nvarying vec4 vFrontColor;\nvarying vec4 vBackColor;\n//position in real world. This is used for clipping.\nvarying vec3 vPosition;\n//state passed to fragment shader\nvarying float vDiscard;\n\nvoid main(void) {\n\t//test if this fragment is to be discarded from vertex shader\n\tif (vDiscard > 0.5) discard;\n\n\t//test if clipping plane is defined\n\tif (uClippingA)\n\t{\n\t\t//clipping test\n\t\tvec4 p = uClippingPlaneA;\n\t\tvec3 x = vPosition;\n\t\tfloat distance = (dot(p.xyz, x) + p.w) / length(p.xyz);\n\t\tif (distance < 0.0) {\n\t\t\tdiscard;\n\t\t}\n\n\t}\n\n\t//test if clipping plane is defined\n\tif (uClippingB)\n\t{\n\t\t//clipping test\n\t\tvec4 p = uClippingPlaneB;\n\t\tvec3 x = vPosition;\n\t\tfloat distance = (dot(p.xyz, x) + p.w) / length(p.xyz);\n\t\tif (distance < 0.0) {\n\t\t\tdiscard;\n\t\t}\n\n\t}\n\n\t//fix wrong normals (supposing the orientation of vertices is correct but normals are flipped)\n\tgl_FragColor = gl_FrontFacing ? vFrontColor : vBackColor;\n}\n",
    pulse_vshader: ' attribute highp vec3 aPosition; attribute highp vec2 aState; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform vec4 uHighlightColour; uniform float uHighlightAlphaMin; uniform float uHighlightAlphaMax; uniform float uSin; varying vec4 vFrontColor; varying vec4 vBackColor; varying vec3 vPosition; varying float vDiscard; void main(void) { int state = int(floor(aState[0] + 0.5)); vDiscard = 0.0; if (state != 253) { vDiscard = 1.0; vFrontColor = vec4(0.0, 0.0, 0.0, 0.0); vBackColor = vec4(0.0, 0.0, 0.0, 0.0); vPosition = vec3(0.0, 0.0, 0.0); gl_Position = vec4(0.0, 0.0, 0.0, 1.0); return; } vec4 baseColor = vec4(uHighlightColour.rgb, uHighlightAlphaMin + (uHighlightAlphaMax - uHighlightAlphaMin) * uSin); vFrontColor = baseColor; vBackColor = baseColor; vPosition = aPosition; gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0); }'
};
//# sourceMappingURL=pulse-highlight-shaders.js.map