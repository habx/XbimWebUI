

/* Copyright (c) 2016, xBIM Team, Northumbria University. All rights reserved.

This javascript library is part of xBIM project. It is provided under the same 
Common Development and Distribution License (CDDL) as the xBIM Toolkit. For 
more information see http://www.openbim.org

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
/*
* This file has been generated by spacker.exe utility. Do not change this file manualy as your changes
* will get lost when the file is regenerated. Original content is located in *.c files.
*/
if (!window.xShaders) window.xShaders = {}
xShaders.pulse_fshader = " precision highp float; uniform vec4 uClippingPlane; varying vec4 vFrontColor; varying vec4 vBackColor; varying vec3 vPosition; varying float vDiscard; void main(void) { if ( vDiscard > 0.001) discard; if (length(uClippingPlane) > 0.001) { vec4 p = uClippingPlane; vec3 x = vPosition; float distance = (dot(p.xyz, x) + p.w) / length(p.xyz); if (distance < 0.0){ discard; } } gl_FragColor = gl_FrontFacing ? vFrontColor : vBackColor; }";
xShaders.pulse_vshader = " attribute highp vec3 aPosition; attribute highp vec2 aState; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform vec4 uHighlightColour; uniform float uHighlightAlphaMin; uniform float uHighlightAlphaMax; uniform float uSin; varying vec4 vFrontColor; varying vec4 vBackColor; varying vec3 vPosition; varying float vDiscard; void main(void) { int state = int(floor(aState[0] + 0.5)); vDiscard = 0.0; if (state != 253) { vDiscard = 1.0; vFrontColor = vec4(0.0, 0.0, 0.0, 0.0); vBackColor = vec4(0.0, 0.0, 0.0, 0.0); vPosition = vec3(0.0, 0.0, 0.0); gl_Position = vec4(0.0, 0.0, 0.0, 1.0); return; } vec3 vertex = getVertexPosition(); vec3 normal = getNormal(); vec3 backNormal = normal * -1.0; vec4 baseColor = vec4(uHighlightColour.rgb, uHighlightAlphaMin + (uHighlightAlphaMax - uHighlightAlphaMax) * uSin); vFrontColor = baseColor; vBackColor = baseColor; vPosition = aPosition; gl_Position = uPMatrix * uMVMatrix * vec4(vertex, 1.0); }";
/**
 * This is constructor of the Navigation Cube plugin for {@link xViewer xBIM Viewer}. It gets optional Image as an argument.
 * The image will be used as a texture of the navigation cube. If you don't specify eny image default one will be used.
 * Image has to be square and its size has to be power of 2.
 * @name xPulseHighlight
 * @constructor
 * @classdesc This is a plugin for xViewer which renders interactive navigation cube. It is customizable in terms of alpha
 * behaviour and its position on the viewer canvas. Use of plugin:
 *
 *     var cube = new xPulseHighlight();
 *     viewer.addPlugin(cube);
 *
 * You can specify your own texture of the cube as an [Image](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image)
 * object argumen in constructor. If you don't specify any image default texture will be used (you can also use this one and enhance it if you want):
 *
 * ![Cube texture](cube_texture.png)
 *
 * @param {Image} [image = null] - optional image to be used for a cube texture.
*/
function xPulseHighlight(image) {
    this._image = image;

    this._initialized = false;

    /**
    * Min alpha of the pulse effect
    * @member {Number} xPulseHighlight#pulseAlphaMin
    */
    this.pulseAlphaMin = 0.2;

    /**
    * Max alpha of the pulse effect
    * @member {Number} xPulseHighlight#pulseAlphaMin
    */
    this.pulseAlphaMax = 0.8;

    /**
    * Period of the pulse (in seconds)
    * @member {Number} xPulseHighlight#highlighting
    */
    this.period = 1.5;
}

xPulseHighlight.prototype.init = function (xviewer) {
    var self = this;
    this.viewer = xviewer;
    var gl = this.viewer._gl;

    //create own shader
    this._shader = null;
    this._initShader();

    this._alphaMin = this.pulseAlphaMin;
    this._alphaMax = this.pulseAlphaMax;
    this._period = this.period * 1000;

    //set own shader for init
    gl.useProgram(this._shader);

    //create uniform and attribute pointers
    this._alphaMinUniformPointer = gl.getUniformLocation(this._shader, "uAlphaMin");
    this._alphaMaxUniformPointer = gl.getUniformLocation(this._shader, "uAlphaMax");
    this._sinUniformPointer = gl.getUniformLocation(this._shader, "uSin");

    //reset original shader program
    gl.useProgram(this.viewer._shaderProgram);

    this._initialized = true;
}

xPulseHighlight.prototype.onBeforeDraw = function () { };

xPulseHighlight.prototype.onBeforePick = function () { };

xPulseHighlight.prototype.onAfterDraw = function() {
    var gl = this.setActive();

    gl.uniform1f(this._alphaMinUniformPointer, this._alphaMin);
    gl.uniform1f(this._alphaMaxUniformPointer, this._alphaMax);
    gl.uniform1f(this._sinUniformPointer, Math.sin(Math.PI * (Date.now() % this._period) / this._period));

    this.draw();

    this.setInactive();
};

xPulseHighlight.prototype.onBeforeDrawId = function () { };

xPulseHighlight.prototype.onAfterDrawId = function () { };

xPulseHighlight.prototype.onBeforeGetId = function() { }

xPulseHighlight.prototype.setActive = function() {
    var gl = this.viewer._gl;
    //set own shader
    gl.useProgram(this._shader);

    return gl;
};

xPulseHighlight.prototype.setInactive = function () {
    var gl = this.viewer._gl;
    //set viewer shader
    gl.useProgram(this.viewer._shaderProgram);
};

xPulseHighlight.prototype.draw = function() {
    if (!this._initialized) return;
    var gl = this.viewer._gl;

    gl.disable(gl.DEPTH_TEST);
    this.viewer._handles.forEach(this.drawHandle.bind(this))
    gl.enable(gl.DEPTH_TEST);
}

xPulseHighlight.prototype.drawHandle = function (handle) {
    var gl = this.viewer._gl;

    if (handle.stopped) return;

    handle.setActive(this._pointers);

    const spans = []

    const currentSpan = []

    for (var i = 0; i < handle._model.states.length; i += 2) {
        if (handle._model.states[i] === xState.HIGHLIGHTED) {
            var index = i / 2;
            if (!currentSpan.length) {
                currentSpan[0] = index
                currentSpan[1] = index
            } else if (currentSpan[1] === index - 1) {
                currentSpan[1] = index
            } else {
                currentSpan[1] += 1
                spans.push(currentSpan)
                currentSpan = [index, index]
            }
        }
    }

    if (currentSpan.length) {
        currentSpan[1] += 1
        spans.push(currentSpan)
    }

    if (spans.length) {
        spans.forEach(function (span) {
            gl.drawArrays(gl.TRIANGLES, span[0], span[1] - span[0]);
        }, handle);
    }
};

xPulseHighlight.prototype._initShader = function () {

    var gl = this.viewer._gl;
    var viewer = this.viewer;
    var compile = function (shader, code) {
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            viewer._error(gl.getShaderInfoLog(shader));
            return null;
        }
    }

    //fragment shader
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    compile(fragmentShader, xShaders.pulse_fshader);

    //vertex shader (the more complicated one)
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    compile(vertexShader, xShaders.pulse_vshader);

    //link program
    this._shader = gl.createProgram();
    gl.attachShader(this._shader, vertexShader);
    gl.attachShader(this._shader, fragmentShader);
    gl.linkProgram(this._shader);

    if (!gl.getProgramParameter(this._shader, gl.LINK_STATUS)) {
        viewer._error('Could not initialise shaders for pulse highlight plugin');
    }
};
